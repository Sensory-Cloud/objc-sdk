// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Common.pbobjc.h"
#import "Validate.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(SENGCpuSummary);
GPBObjCClassDeclaration(SENGMemorySummary);
GPBObjCClassDeclaration(SENGServiceHealth);

#pragma mark - SENGCommonRoot

@implementation SENGCommonRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[ValidateRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - SENGCommonRoot_FileDescriptor

static GPBFileDescriptor *SENGCommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"sensory.api.common"
                                                 objcPrefix:@"SENG"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SENGVoid

GPBEnumDescriptor *SENGVoid_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VoidValue\000";
    static const int32_t values[] = {
        SENGVoid_VoidValue,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGVoid)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGVoid_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGVoid_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGVoid_VoidValue:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGKeyType

GPBEnumDescriptor *SENGKeyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PublicKey\000PublicKeyEd25519\000SharedSecret\000"
        "Aes256\000";
    static const int32_t values[] = {
        SENGKeyType_PublicKey,
        SENGKeyType_PublicKeyEd25519,
        SENGKeyType_SharedSecret,
        SENGKeyType_Aes256,
    };
    static const char *extraTextFormatInfo = "\001\003c\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGKeyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGKeyType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGKeyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGKeyType_PublicKey:
    case SENGKeyType_PublicKeyEd25519:
    case SENGKeyType_SharedSecret:
    case SENGKeyType_Aes256:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGFeatureFlag

GPBEnumDescriptor *SENGFeatureFlag_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TssvAll\000TsAll\000TnlAll\000";
    static const int32_t values[] = {
        SENGFeatureFlag_TssvAll,
        SENGFeatureFlag_TsAll,
        SENGFeatureFlag_TnlAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGFeatureFlag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGFeatureFlag_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGFeatureFlag_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGFeatureFlag_TssvAll:
    case SENGFeatureFlag_TsAll:
    case SENGFeatureFlag_TnlAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGModelType

GPBEnumDescriptor *SENGModelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000VoiceBiometricTextIndependent\000Vo"
        "iceBiometricWakeword\000VoiceEventWakeword\000"
        "VoiceTranscribeGrammar\000VoiceTranscribeCo"
        "mmandAndSearch\000VoiceRecognitionActivityD"
        "etection\000VoiceFeatureExtractor\000VoiceBiom"
        "etricLivenessDigit\000VoiceBiometricTextDep"
        "endent\000VoiceSynthesis\000SoundEventEnrollab"
        "le\000SoundEventRevalidation\000SoundEventFixe"
        "d\000SoundSceneFixed\000FaceBiometric\000FaceReco"
        "gnition\000ObjectRecognition\000ImageTransform"
        "\000FaceEmbedding\000LlmGpt35\000";
    static const int32_t values[] = {
        SENGModelType_Unknown,
        SENGModelType_VoiceBiometricTextIndependent,
        SENGModelType_VoiceBiometricWakeword,
        SENGModelType_VoiceEventWakeword,
        SENGModelType_VoiceTranscribeGrammar,
        SENGModelType_VoiceTranscribeCommandAndSearch,
        SENGModelType_VoiceRecognitionActivityDetection,
        SENGModelType_VoiceFeatureExtractor,
        SENGModelType_VoiceBiometricLivenessDigit,
        SENGModelType_VoiceBiometricTextDependent,
        SENGModelType_VoiceSynthesis,
        SENGModelType_SoundEventEnrollable,
        SENGModelType_SoundEventRevalidation,
        SENGModelType_SoundEventFixed,
        SENGModelType_SoundSceneFixed,
        SENGModelType_FaceBiometric,
        SENGModelType_FaceRecognition,
        SENGModelType_ObjectRecognition,
        SENGModelType_ImageTransform,
        SENGModelType_FaceEmbedding,
        SENGModelType_LlmGpt35,
    };
    static const char *extraTextFormatInfo = "\001\024c\343\201\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGModelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGModelType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGModelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGModelType_Unknown:
    case SENGModelType_VoiceBiometricTextIndependent:
    case SENGModelType_VoiceBiometricWakeword:
    case SENGModelType_VoiceEventWakeword:
    case SENGModelType_VoiceTranscribeGrammar:
    case SENGModelType_VoiceTranscribeCommandAndSearch:
    case SENGModelType_VoiceRecognitionActivityDetection:
    case SENGModelType_VoiceFeatureExtractor:
    case SENGModelType_VoiceBiometricLivenessDigit:
    case SENGModelType_VoiceBiometricTextDependent:
    case SENGModelType_VoiceSynthesis:
    case SENGModelType_SoundEventEnrollable:
    case SENGModelType_SoundEventRevalidation:
    case SENGModelType_SoundEventFixed:
    case SENGModelType_SoundSceneFixed:
    case SENGModelType_FaceBiometric:
    case SENGModelType_FaceRecognition:
    case SENGModelType_ObjectRecognition:
    case SENGModelType_ImageTransform:
    case SENGModelType_FaceEmbedding:
    case SENGModelType_LlmGpt35:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGTechnologyType

GPBEnumDescriptor *SENGTechnologyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NotSet\000Tssv\000Ts\000Tnl\000Stt\000Tts\000SoundId\000";
    static const int32_t values[] = {
        SENGTechnologyType_NotSet,
        SENGTechnologyType_Tssv,
        SENGTechnologyType_Ts,
        SENGTechnologyType_Tnl,
        SENGTechnologyType_Stt,
        SENGTechnologyType_Tts,
        SENGTechnologyType_SoundId,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGTechnologyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGTechnologyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGTechnologyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGTechnologyType_NotSet:
    case SENGTechnologyType_Tssv:
    case SENGTechnologyType_Ts:
    case SENGTechnologyType_Tnl:
    case SENGTechnologyType_Stt:
    case SENGTechnologyType_Tts:
    case SENGTechnologyType_SoundId:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGCompressionType

GPBEnumDescriptor *SENGCompressionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ImageGrayscale\000";
    static const int32_t values[] = {
        SENGCompressionType_ImageGrayscale,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGCompressionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGCompressionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGCompressionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGCompressionType_ImageGrayscale:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGClientType

GPBEnumDescriptor *SENGClientType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Device\000Cluster\000User\000SuperUser\000Bi"
        "llingUser\000ReadOnlyUser\000Root\000";
    static const int32_t values[] = {
        SENGClientType_Invalid,
        SENGClientType_Device,
        SENGClientType_Cluster,
        SENGClientType_User,
        SENGClientType_SuperUser,
        SENGClientType_BillingUser,
        SENGClientType_ReadOnlyUser,
        SENGClientType_Root,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGClientType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGClientType_Invalid:
    case SENGClientType_Device:
    case SENGClientType_Cluster:
    case SENGClientType_User:
    case SENGClientType_SuperUser:
    case SENGClientType_BillingUser:
    case SENGClientType_ReadOnlyUser:
    case SENGClientType_Root:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGUsageEventType

GPBEnumDescriptor *SENGUsageEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Authentication\000Recognition\000Enrollment\000Sy"
        "nthesis\000Transcription\000Llm\000";
    static const int32_t values[] = {
        SENGUsageEventType_Authentication,
        SENGUsageEventType_Recognition,
        SENGUsageEventType_Enrollment,
        SENGUsageEventType_Synthesis,
        SENGUsageEventType_Transcription,
        SENGUsageEventType_Llm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGUsageEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGUsageEventType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGUsageEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGUsageEventType_Authentication:
    case SENGUsageEventType_Recognition:
    case SENGUsageEventType_Enrollment:
    case SENGUsageEventType_Synthesis:
    case SENGUsageEventType_Transcription:
    case SENGUsageEventType_Llm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENGServerType

GPBEnumDescriptor *SENGServerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Titan\000Io\000";
    static const int32_t values[] = {
        SENGServerType_Titan,
        SENGServerType_Io,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENGServerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENGServerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENGServerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENGServerType_Titan:
    case SENGServerType_Io:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SENGCompressionConfiguration

@implementation SENGCompressionConfiguration

@dynamic compressionsArray, compressionsArray_Count;

typedef struct SENGCompressionConfiguration__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *compressionsArray;
} SENGCompressionConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "compressionsArray",
        .dataTypeSpecific.enumDescFunc = SENGCompressionType_EnumDescriptor,
        .number = SENGCompressionConfiguration_FieldNumber_CompressionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENGCompressionConfiguration__storage_, compressionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGCompressionConfiguration class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGCompressionConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGTokenResponse

@implementation SENGTokenResponse

@dynamic accessToken;
@dynamic expiresIn;
@dynamic keyId;
@dynamic tokenType;

typedef struct SENGTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t expiresIn;
  NSString *accessToken;
  NSString *keyId;
  NSString *tokenType;
} SENGTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTokenResponse_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGTokenResponse__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiresIn",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTokenResponse_FieldNumber_ExpiresIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGTokenResponse__storage_, expiresIn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTokenResponse_FieldNumber_KeyId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGTokenResponse__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenType",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTokenResponse_FieldNumber_TokenType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGTokenResponse__storage_, tokenType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGTokenResponse class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGTokenResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\t\000\003\005\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGServiceHealth

@implementation SENGServiceHealth

@dynamic isHealthy;
@dynamic name;
@dynamic message;

typedef struct SENGServiceHealth__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *message;
} SENGServiceHealth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHealthy",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServiceHealth_FieldNumber_IsHealthy,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServiceHealth_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGServiceHealth__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServiceHealth_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGServiceHealth__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGServiceHealth class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGServiceHealth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGServerHealthResponse

@implementation SENGServerHealthResponse

@dynamic isHealthy;
@dynamic serverVersion;
@dynamic id_p;
@dynamic servicesArray, servicesArray_Count;
@dynamic serverType;
@dynamic isLeader;

typedef struct SENGServerHealthResponse__storage_ {
  uint32_t _has_storage_[1];
  SENGServerType serverType;
  NSString *serverVersion;
  NSString *id_p;
  NSMutableArray *servicesArray;
} SENGServerHealthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHealthy",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServerHealthResponse_FieldNumber_IsHealthy,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "serverVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServerHealthResponse_FieldNumber_ServerVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGServerHealthResponse__storage_, serverVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServerHealthResponse_FieldNumber_Id_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGServerHealthResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "servicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SENGServiceHealth),
        .number = SENGServerHealthResponse_FieldNumber_ServicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENGServerHealthResponse__storage_, servicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverType",
        .dataTypeSpecific.enumDescFunc = SENGServerType_EnumDescriptor,
        .number = SENGServerHealthResponse_FieldNumber_ServerType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENGServerHealthResponse__storage_, serverType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isLeader",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGServerHealthResponse_FieldNumber_IsLeader,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGServerHealthResponse class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGServerHealthResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\r\000\005\n\000\006\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENGServerHealthResponse_ServerType_RawValue(SENGServerHealthResponse *message) {
  GPBDescriptor *descriptor = [SENGServerHealthResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGServerHealthResponse_FieldNumber_ServerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENGServerHealthResponse_ServerType_RawValue(SENGServerHealthResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SENGServerHealthResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGServerHealthResponse_FieldNumber_ServerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SENGSystemSummary

@implementation SENGSystemSummary

@dynamic hasCpu, cpu;
@dynamic hasMemory, memory;

typedef struct SENGSystemSummary__storage_ {
  uint32_t _has_storage_[1];
  SENGCpuSummary *cpu;
  SENGMemorySummary *memory;
} SENGSystemSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cpu",
        .dataTypeSpecific.clazz = GPBObjCClass(SENGCpuSummary),
        .number = SENGSystemSummary_FieldNumber_Cpu,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGSystemSummary__storage_, cpu),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memory",
        .dataTypeSpecific.clazz = GPBObjCClass(SENGMemorySummary),
        .number = SENGSystemSummary_FieldNumber_Memory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGSystemSummary__storage_, memory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGSystemSummary class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGSystemSummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGCpuSummary

@implementation SENGCpuSummary

@dynamic user;
@dynamic nice;
@dynamic system;
@dynamic idle;
@dynamic ioWait;
@dynamic irq;
@dynamic softIrq;
@dynamic steal;
@dynamic guest;
@dynamic guestNice;

typedef struct SENGCpuSummary__storage_ {
  uint32_t _has_storage_[1];
  uint64_t user;
  uint64_t nice;
  uint64_t system;
  uint64_t idle;
  uint64_t ioWait;
  uint64_t irq;
  uint64_t softIrq;
  uint64_t steal;
  uint64_t guest;
  uint64_t guestNice;
} SENGCpuSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, user),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nice",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_Nice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, nice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "system",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_System,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, system),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "idle",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_Idle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, idle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ioWait",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_IoWait,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, ioWait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "irq",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_Irq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, irq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "softIrq",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_SoftIrq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, softIrq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "steal",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_Steal,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, steal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "guest",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_Guest,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, guest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "guestNice",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCpuSummary_FieldNumber_GuestNice,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SENGCpuSummary__storage_, guestNice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGCpuSummary class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGCpuSummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\005\006\000\007\007\000\n\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGMemorySummary

@implementation SENGMemorySummary

@dynamic memTotal;
@dynamic memFree;
@dynamic memAvailable;

typedef struct SENGMemorySummary__storage_ {
  uint32_t _has_storage_[1];
  uint64_t memTotal;
  uint64_t memFree;
  uint64_t memAvailable;
} SENGMemorySummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memTotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGMemorySummary_FieldNumber_MemTotal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGMemorySummary__storage_, memTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "memFree",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGMemorySummary_FieldNumber_MemFree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGMemorySummary__storage_, memFree),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "memAvailable",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGMemorySummary_FieldNumber_MemAvailable,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGMemorySummary__storage_, memAvailable),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGMemorySummary class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGMemorySummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\007\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGGenericClient

@implementation SENGGenericClient

@dynamic clientId;
@dynamic secret;

typedef struct SENGGenericClient__storage_ {
  uint32_t _has_storage_[1];
  NSString *clientId;
  NSString *secret;
} SENGGenericClient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGGenericClient_FieldNumber_ClientId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGGenericClient__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secret",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGGenericClient_FieldNumber_Secret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGGenericClient__storage_, secret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGGenericClient class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGGenericClient__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGTenantResponse

@implementation SENGTenantResponse

@dynamic id_p;
@dynamic name;
@dynamic hasCreatedAt, createdAt;
@dynamic hasUpdatedAt, updatedAt;

typedef struct SENGTenantResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  GPBTimestamp *createdAt;
  GPBTimestamp *updatedAt;
} SENGTenantResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTenantResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGTenantResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGTenantResponse_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGTenantResponse__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENGTenantResponse_FieldNumber_CreatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGTenantResponse__storage_, createdAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENGTenantResponse_FieldNumber_UpdatedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGTenantResponse__storage_, updatedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGTenantResponse class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGTenantResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGPaginationOptions

@implementation SENGPaginationOptions

@dynamic ordering;
@dynamic decending;
@dynamic pageIndex;
@dynamic pageSize;

typedef struct SENGPaginationOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageIndex;
  int32_t pageSize;
  NSString *ordering;
} SENGPaginationOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ordering",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationOptions_FieldNumber_Ordering,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGPaginationOptions__storage_, ordering),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "decending",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationOptions_FieldNumber_Decending,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationOptions_FieldNumber_PageIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGPaginationOptions__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationOptions_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENGPaginationOptions__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGPaginationOptions class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGPaginationOptions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGPaginationResponse

@implementation SENGPaginationResponse

@dynamic ordering;
@dynamic decending;
@dynamic possibleOrderingsArray, possibleOrderingsArray_Count;
@dynamic totalCount;
@dynamic pageSize;
@dynamic prevPageIndex;
@dynamic currentPageIndex;
@dynamic nextPageIndex;

typedef struct SENGPaginationResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t prevPageIndex;
  int32_t currentPageIndex;
  int32_t nextPageIndex;
  NSString *ordering;
  NSMutableArray *possibleOrderingsArray;
  int64_t totalCount;
} SENGPaginationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ordering",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_Ordering,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, ordering),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "decending",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_Decending,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "possibleOrderingsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_PossibleOrderingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, possibleOrderingsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_TotalCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "prevPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_PrevPageIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, prevPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currentPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_CurrentPageIndex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, currentPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGPaginationResponse_FieldNumber_NextPageIndex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SENGPaginationResponse__storage_, nextPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGPaginationResponse class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGPaginationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\003\000possibleOrderings\000\004\n\000\005\010\000\006\r\000\007\020\000\010\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGEnrollmentToken

@implementation SENGEnrollmentToken

@dynamic token;
@dynamic expiration;

typedef struct SENGEnrollmentToken__storage_ {
  uint32_t _has_storage_[1];
  NSData *token;
  int64_t expiration;
} SENGEnrollmentToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGEnrollmentToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGEnrollmentToken__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGEnrollmentToken_FieldNumber_Expiration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGEnrollmentToken__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGEnrollmentToken class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGEnrollmentToken__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGCreateKeyRequest

@implementation SENGCreateKeyRequest

@dynamic name;
@dynamic keyType;
@dynamic value;
@dynamic expiration;

typedef struct SENGCreateKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  SENGKeyType keyType;
  NSString *name;
  NSString *value;
  int64_t expiration;
} SENGCreateKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCreateKeyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGCreateKeyRequest__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = SENGKeyType_EnumDescriptor,
        .number = SENGCreateKeyRequest_FieldNumber_KeyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGCreateKeyRequest__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCreateKeyRequest_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGCreateKeyRequest__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGCreateKeyRequest_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGCreateKeyRequest__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGCreateKeyRequest class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGCreateKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENGCreateKeyRequest_KeyType_RawValue(SENGCreateKeyRequest *message) {
  GPBDescriptor *descriptor = [SENGCreateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGCreateKeyRequest_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENGCreateKeyRequest_KeyType_RawValue(SENGCreateKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [SENGCreateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGCreateKeyRequest_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SENGKeyResponse

@implementation SENGKeyResponse

@dynamic id_p;
@dynamic name;
@dynamic keyType;
@dynamic expiration;
@dynamic tenantId;
@dynamic disabled;

typedef struct SENGKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  SENGKeyType keyType;
  NSString *id_p;
  NSString *name;
  NSString *tenantId;
  int64_t expiration;
} SENGKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGKeyResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGKeyResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGKeyResponse_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGKeyResponse__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = SENGKeyType_EnumDescriptor,
        .number = SENGKeyResponse_FieldNumber_KeyType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENGKeyResponse__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGKeyResponse_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENGKeyResponse__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tenantId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGKeyResponse_FieldNumber_TenantId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENGKeyResponse__storage_, tenantId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "disabled",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGKeyResponse_FieldNumber_Disabled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGKeyResponse class]
                                     rootClass:[SENGCommonRoot class]
                                          file:SENGCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\007\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENGKeyResponse_KeyType_RawValue(SENGKeyResponse *message) {
  GPBDescriptor *descriptor = [SENGKeyResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGKeyResponse_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENGKeyResponse_KeyType_RawValue(SENGKeyResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SENGKeyResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENGKeyResponse_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
