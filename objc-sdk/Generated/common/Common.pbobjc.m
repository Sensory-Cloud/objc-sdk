// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/common.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Common.pbobjc.h"
#import "Validate.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(SENCpuSummary);
GPBObjCClassDeclaration(SENMemorySummary);
GPBObjCClassDeclaration(SENServiceHealth);

#pragma mark - SENCommonRoot

@implementation SENCommonRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[SENValidateRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - SENCommonRoot_FileDescriptor

static GPBFileDescriptor *SENCommonRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"sensory.api.common"
                                                 objcPrefix:@"SEN"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SENVoid

GPBEnumDescriptor *SENVoid_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "VoidValue\000";
    static const int32_t values[] = {
        SENVoid_VoidValue,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENVoid)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENVoid_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENVoid_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENVoid_VoidValue:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENKeyType

GPBEnumDescriptor *SENKeyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PublicKey\000PublicKeyEd25519\000SharedSecret\000"
        "Aes256\000";
    static const int32_t values[] = {
        SENKeyType_PublicKey,
        SENKeyType_PublicKeyEd25519,
        SENKeyType_SharedSecret,
        SENKeyType_Aes256,
    };
    static const char *extraTextFormatInfo = "\001\003c\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENKeyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENKeyType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENKeyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENKeyType_PublicKey:
    case SENKeyType_PublicKeyEd25519:
    case SENKeyType_SharedSecret:
    case SENKeyType_Aes256:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENFeatureFlag

GPBEnumDescriptor *SENFeatureFlag_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TssvAll\000TsAll\000TnlAll\000";
    static const int32_t values[] = {
        SENFeatureFlag_TssvAll,
        SENFeatureFlag_TsAll,
        SENFeatureFlag_TnlAll,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENFeatureFlag)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENFeatureFlag_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENFeatureFlag_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENFeatureFlag_TssvAll:
    case SENFeatureFlag_TsAll:
    case SENFeatureFlag_TnlAll:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENModelType

GPBEnumDescriptor *SENModelType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000VoiceBiometricTextIndependent\000Vo"
        "iceBiometricWakeword\000VoiceEventWakeword\000"
        "VoiceTranscribeGrammar\000VoiceTranscribeCo"
        "mmandAndSearch\000VoiceRecognitionActivityD"
        "etection\000VoiceFeatureExtractor\000VoiceBiom"
        "etricLivenessDigit\000VoiceBiometricTextDep"
        "endent\000VoiceSynthesis\000SoundEventEnrollab"
        "le\000SoundEventRevalidation\000SoundEventFixe"
        "d\000SoundSceneFixed\000FaceBiometric\000FaceReco"
        "gnition\000ObjectRecognition\000ImageTransform"
        "\000";
    static const int32_t values[] = {
        SENModelType_Unknown,
        SENModelType_VoiceBiometricTextIndependent,
        SENModelType_VoiceBiometricWakeword,
        SENModelType_VoiceEventWakeword,
        SENModelType_VoiceTranscribeGrammar,
        SENModelType_VoiceTranscribeCommandAndSearch,
        SENModelType_VoiceRecognitionActivityDetection,
        SENModelType_VoiceFeatureExtractor,
        SENModelType_VoiceBiometricLivenessDigit,
        SENModelType_VoiceBiometricTextDependent,
        SENModelType_VoiceSynthesis,
        SENModelType_SoundEventEnrollable,
        SENModelType_SoundEventRevalidation,
        SENModelType_SoundEventFixed,
        SENModelType_SoundSceneFixed,
        SENModelType_FaceBiometric,
        SENModelType_FaceRecognition,
        SENModelType_ObjectRecognition,
        SENModelType_ImageTransform,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENModelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENModelType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENModelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENModelType_Unknown:
    case SENModelType_VoiceBiometricTextIndependent:
    case SENModelType_VoiceBiometricWakeword:
    case SENModelType_VoiceEventWakeword:
    case SENModelType_VoiceTranscribeGrammar:
    case SENModelType_VoiceTranscribeCommandAndSearch:
    case SENModelType_VoiceRecognitionActivityDetection:
    case SENModelType_VoiceFeatureExtractor:
    case SENModelType_VoiceBiometricLivenessDigit:
    case SENModelType_VoiceBiometricTextDependent:
    case SENModelType_VoiceSynthesis:
    case SENModelType_SoundEventEnrollable:
    case SENModelType_SoundEventRevalidation:
    case SENModelType_SoundEventFixed:
    case SENModelType_SoundSceneFixed:
    case SENModelType_FaceBiometric:
    case SENModelType_FaceRecognition:
    case SENModelType_ObjectRecognition:
    case SENModelType_ImageTransform:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENTechnologyType

GPBEnumDescriptor *SENTechnologyType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "NotSet\000Tssv\000Ts\000Tnl\000Stt\000Tts\000";
    static const int32_t values[] = {
        SENTechnologyType_NotSet,
        SENTechnologyType_Tssv,
        SENTechnologyType_Ts,
        SENTechnologyType_Tnl,
        SENTechnologyType_Stt,
        SENTechnologyType_Tts,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENTechnologyType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENTechnologyType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENTechnologyType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENTechnologyType_NotSet:
    case SENTechnologyType_Tssv:
    case SENTechnologyType_Ts:
    case SENTechnologyType_Tnl:
    case SENTechnologyType_Stt:
    case SENTechnologyType_Tts:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENCompressionType

GPBEnumDescriptor *SENCompressionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ImageGrayscale\000";
    static const int32_t values[] = {
        SENCompressionType_ImageGrayscale,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENCompressionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENCompressionType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENCompressionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENCompressionType_ImageGrayscale:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENClientType

GPBEnumDescriptor *SENClientType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Invalid\000Device\000Cluster\000User\000SuperUser\000Bi"
        "llingUser\000ReadOnlyUser\000Root\000";
    static const int32_t values[] = {
        SENClientType_Invalid,
        SENClientType_Device,
        SENClientType_Cluster,
        SENClientType_User,
        SENClientType_SuperUser,
        SENClientType_BillingUser,
        SENClientType_ReadOnlyUser,
        SENClientType_Root,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENClientType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENClientType_Invalid:
    case SENClientType_Device:
    case SENClientType_Cluster:
    case SENClientType_User:
    case SENClientType_SuperUser:
    case SENClientType_BillingUser:
    case SENClientType_ReadOnlyUser:
    case SENClientType_Root:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENUsageEventType

GPBEnumDescriptor *SENUsageEventType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Authentication\000Recognition\000Enrollment\000Sy"
        "nthesis\000Transcription\000";
    static const int32_t values[] = {
        SENUsageEventType_Authentication,
        SENUsageEventType_Recognition,
        SENUsageEventType_Enrollment,
        SENUsageEventType_Synthesis,
        SENUsageEventType_Transcription,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENUsageEventType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENUsageEventType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENUsageEventType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENUsageEventType_Authentication:
    case SENUsageEventType_Recognition:
    case SENUsageEventType_Enrollment:
    case SENUsageEventType_Synthesis:
    case SENUsageEventType_Transcription:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SENServerType

GPBEnumDescriptor *SENServerType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Titan\000Io\000";
    static const int32_t values[] = {
        SENServerType_Titan,
        SENServerType_Io,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENServerType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENServerType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENServerType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENServerType_Titan:
    case SENServerType_Io:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SENCompressionConfiguration

@implementation SENCompressionConfiguration

@dynamic compressionsArray, compressionsArray_Count;

typedef struct SENCompressionConfiguration__storage_ {
  uint32_t _has_storage_[1];
  GPBEnumArray *compressionsArray;
} SENCompressionConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "compressionsArray",
        .dataTypeSpecific.enumDescFunc = SENCompressionType_EnumDescriptor,
        .number = SENCompressionConfiguration_FieldNumber_CompressionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENCompressionConfiguration__storage_, compressionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENCompressionConfiguration class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENCompressionConfiguration__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENTokenResponse

@implementation SENTokenResponse

@dynamic accessToken;
@dynamic expiresIn;
@dynamic keyId;
@dynamic tokenType;

typedef struct SENTokenResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t expiresIn;
  NSString *accessToken;
  NSString *keyId;
  NSString *tokenType;
} SENTokenResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accessToken",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTokenResponse_FieldNumber_AccessToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENTokenResponse__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiresIn",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTokenResponse_FieldNumber_ExpiresIn,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENTokenResponse__storage_, expiresIn),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTokenResponse_FieldNumber_KeyId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENTokenResponse__storage_, keyId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenType",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTokenResponse_FieldNumber_TokenType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENTokenResponse__storage_, tokenType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENTokenResponse class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENTokenResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\t\000\003\005\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENServiceHealth

@implementation SENServiceHealth

@dynamic isHealthy;
@dynamic name;
@dynamic message;

typedef struct SENServiceHealth__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *message;
} SENServiceHealth__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHealthy",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServiceHealth_FieldNumber_IsHealthy,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServiceHealth_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENServiceHealth__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServiceHealth_FieldNumber_Message,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENServiceHealth__storage_, message),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENServiceHealth class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENServiceHealth__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENServerHealthResponse

@implementation SENServerHealthResponse

@dynamic isHealthy;
@dynamic serverVersion;
@dynamic id_p;
@dynamic servicesArray, servicesArray_Count;
@dynamic serverType;
@dynamic isLeader;

typedef struct SENServerHealthResponse__storage_ {
  uint32_t _has_storage_[1];
  SENServerType serverType;
  NSString *serverVersion;
  NSString *id_p;
  NSMutableArray *servicesArray;
} SENServerHealthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isHealthy",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServerHealthResponse_FieldNumber_IsHealthy,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "serverVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServerHealthResponse_FieldNumber_ServerVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENServerHealthResponse__storage_, serverVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServerHealthResponse_FieldNumber_Id_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENServerHealthResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "servicesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(SENServiceHealth),
        .number = SENServerHealthResponse_FieldNumber_ServicesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENServerHealthResponse__storage_, servicesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverType",
        .dataTypeSpecific.enumDescFunc = SENServerType_EnumDescriptor,
        .number = SENServerHealthResponse_FieldNumber_ServerType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENServerHealthResponse__storage_, serverType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isLeader",
        .dataTypeSpecific.clazz = Nil,
        .number = SENServerHealthResponse_FieldNumber_IsLeader,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENServerHealthResponse class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENServerHealthResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\t\000\002\r\000\005\n\000\006\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENServerHealthResponse_ServerType_RawValue(SENServerHealthResponse *message) {
  GPBDescriptor *descriptor = [SENServerHealthResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENServerHealthResponse_FieldNumber_ServerType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENServerHealthResponse_ServerType_RawValue(SENServerHealthResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SENServerHealthResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENServerHealthResponse_FieldNumber_ServerType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SENSystemSummary

@implementation SENSystemSummary

@dynamic hasCpu, cpu;
@dynamic hasMemory, memory;

typedef struct SENSystemSummary__storage_ {
  uint32_t _has_storage_[1];
  SENCpuSummary *cpu;
  SENMemorySummary *memory;
} SENSystemSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cpu",
        .dataTypeSpecific.clazz = GPBObjCClass(SENCpuSummary),
        .number = SENSystemSummary_FieldNumber_Cpu,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENSystemSummary__storage_, cpu),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memory",
        .dataTypeSpecific.clazz = GPBObjCClass(SENMemorySummary),
        .number = SENSystemSummary_FieldNumber_Memory,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENSystemSummary__storage_, memory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENSystemSummary class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENSystemSummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENCpuSummary

@implementation SENCpuSummary

@dynamic user;
@dynamic nice;
@dynamic system;
@dynamic idle;
@dynamic ioWait;
@dynamic irq;
@dynamic softIrq;
@dynamic steal;
@dynamic guest;
@dynamic guestNice;

typedef struct SENCpuSummary__storage_ {
  uint32_t _has_storage_[1];
  uint64_t user;
  uint64_t nice;
  uint64_t system;
  uint64_t idle;
  uint64_t ioWait;
  uint64_t irq;
  uint64_t softIrq;
  uint64_t steal;
  uint64_t guest;
  uint64_t guestNice;
} SENCpuSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, user),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "nice",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_Nice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, nice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "system",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_System,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, system),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "idle",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_Idle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, idle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ioWait",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_IoWait,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, ioWait),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "irq",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_Irq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, irq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "softIrq",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_SoftIrq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, softIrq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "steal",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_Steal,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, steal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "guest",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_Guest,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, guest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "guestNice",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCpuSummary_FieldNumber_GuestNice,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(SENCpuSummary__storage_, guestNice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENCpuSummary class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENCpuSummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\005\006\000\007\007\000\n\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENMemorySummary

@implementation SENMemorySummary

@dynamic memTotal;
@dynamic memFree;
@dynamic memAvailable;

typedef struct SENMemorySummary__storage_ {
  uint32_t _has_storage_[1];
  uint64_t memTotal;
  uint64_t memFree;
  uint64_t memAvailable;
} SENMemorySummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memTotal",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMemorySummary_FieldNumber_MemTotal,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENMemorySummary__storage_, memTotal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "memFree",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMemorySummary_FieldNumber_MemFree,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENMemorySummary__storage_, memFree),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "memAvailable",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMemorySummary_FieldNumber_MemAvailable,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENMemorySummary__storage_, memAvailable),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENMemorySummary class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENMemorySummary__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\010\000\002\007\000\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENGenericClient

@implementation SENGenericClient

@dynamic clientId;
@dynamic secret;

typedef struct SENGenericClient__storage_ {
  uint32_t _has_storage_[1];
  NSString *clientId;
  NSString *secret;
} SENGenericClient__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGenericClient_FieldNumber_ClientId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENGenericClient__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "secret",
        .dataTypeSpecific.clazz = Nil,
        .number = SENGenericClient_FieldNumber_Secret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENGenericClient__storage_, secret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENGenericClient class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENGenericClient__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENTenantResponse

@implementation SENTenantResponse

@dynamic id_p;
@dynamic name;
@dynamic hasCreatedAt, createdAt;
@dynamic hasUpdatedAt, updatedAt;

typedef struct SENTenantResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *id_p;
  NSString *name;
  GPBTimestamp *createdAt;
  GPBTimestamp *updatedAt;
} SENTenantResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTenantResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENTenantResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTenantResponse_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENTenantResponse__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createdAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTenantResponse_FieldNumber_CreatedAt,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENTenantResponse__storage_, createdAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updatedAt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTenantResponse_FieldNumber_UpdatedAt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENTenantResponse__storage_, updatedAt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENTenantResponse class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENTenantResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENPaginationOptions

@implementation SENPaginationOptions

@dynamic ordering;
@dynamic decending;
@dynamic pageIndex;
@dynamic pageSize;

typedef struct SENPaginationOptions__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageIndex;
  int32_t pageSize;
  NSString *ordering;
} SENPaginationOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ordering",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationOptions_FieldNumber_Ordering,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENPaginationOptions__storage_, ordering),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "decending",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationOptions_FieldNumber_Decending,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationOptions_FieldNumber_PageIndex,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENPaginationOptions__storage_, pageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationOptions_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENPaginationOptions__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENPaginationOptions class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENPaginationOptions__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENPaginationResponse

@implementation SENPaginationResponse

@dynamic ordering;
@dynamic decending;
@dynamic possibleOrderingsArray, possibleOrderingsArray_Count;
@dynamic totalCount;
@dynamic pageSize;
@dynamic prevPageIndex;
@dynamic currentPageIndex;
@dynamic nextPageIndex;

typedef struct SENPaginationResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  int32_t prevPageIndex;
  int32_t currentPageIndex;
  int32_t nextPageIndex;
  NSString *ordering;
  NSMutableArray *possibleOrderingsArray;
  int64_t totalCount;
} SENPaginationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ordering",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_Ordering,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, ordering),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "decending",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_Decending,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "possibleOrderingsArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_PossibleOrderingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, possibleOrderingsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_TotalCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_PageSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, pageSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "prevPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_PrevPageIndex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, prevPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "currentPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_CurrentPageIndex,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, currentPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextPageIndex",
        .dataTypeSpecific.clazz = Nil,
        .number = SENPaginationResponse_FieldNumber_NextPageIndex,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SENPaginationResponse__storage_, nextPageIndex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENPaginationResponse class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENPaginationResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\003\000possibleOrderings\000\004\n\000\005\010\000\006\r\000\007\020\000\010\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENEnrollmentToken

@implementation SENEnrollmentToken

@dynamic token;
@dynamic expiration;

typedef struct SENEnrollmentToken__storage_ {
  uint32_t _has_storage_[1];
  NSData *token;
  int64_t expiration;
} SENEnrollmentToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "token",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnrollmentToken_FieldNumber_Token,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENEnrollmentToken__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnrollmentToken_FieldNumber_Expiration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENEnrollmentToken__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENEnrollmentToken class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENEnrollmentToken__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENCreateKeyRequest

@implementation SENCreateKeyRequest

@dynamic name;
@dynamic keyType;
@dynamic value;
@dynamic expiration;

typedef struct SENCreateKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  SENKeyType keyType;
  NSString *name;
  NSString *value;
  int64_t expiration;
} SENCreateKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCreateKeyRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENCreateKeyRequest__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = SENKeyType_EnumDescriptor,
        .number = SENCreateKeyRequest_FieldNumber_KeyType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENCreateKeyRequest__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCreateKeyRequest_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENCreateKeyRequest__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENCreateKeyRequest_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENCreateKeyRequest__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENCreateKeyRequest class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENCreateKeyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENCreateKeyRequest_KeyType_RawValue(SENCreateKeyRequest *message) {
  GPBDescriptor *descriptor = [SENCreateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENCreateKeyRequest_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENCreateKeyRequest_KeyType_RawValue(SENCreateKeyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [SENCreateKeyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENCreateKeyRequest_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - SENKeyResponse

@implementation SENKeyResponse

@dynamic id_p;
@dynamic name;
@dynamic keyType;
@dynamic expiration;
@dynamic tenantId;
@dynamic disabled;

typedef struct SENKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  SENKeyType keyType;
  NSString *id_p;
  NSString *name;
  NSString *tenantId;
  int64_t expiration;
} SENKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENKeyResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENKeyResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = SENKeyResponse_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENKeyResponse__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyType",
        .dataTypeSpecific.enumDescFunc = SENKeyType_EnumDescriptor,
        .number = SENKeyResponse_FieldNumber_KeyType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENKeyResponse__storage_, keyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.clazz = Nil,
        .number = SENKeyResponse_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENKeyResponse__storage_, expiration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tenantId",
        .dataTypeSpecific.clazz = Nil,
        .number = SENKeyResponse_FieldNumber_TenantId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENKeyResponse__storage_, tenantId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "disabled",
        .dataTypeSpecific.clazz = Nil,
        .number = SENKeyResponse_FieldNumber_Disabled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENKeyResponse class]
                                     rootClass:[SENCommonRoot class]
                                          file:SENCommonRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENKeyResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\007\000\005\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SENKeyResponse_KeyType_RawValue(SENKeyResponse *message) {
  GPBDescriptor *descriptor = [SENKeyResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENKeyResponse_FieldNumber_KeyType];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSENKeyResponse_KeyType_RawValue(SENKeyResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [SENKeyResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SENKeyResponse_FieldNumber_KeyType];
  GPBSetMessageRawEnumField(message, field, value);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
