// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: validate/validate.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Validate.pbobjc.h"
#import "Descriptor.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(GPBDuration);
GPBObjCClassDeclaration(GPBFieldOptions);
GPBObjCClassDeclaration(GPBMessageOptions);
GPBObjCClassDeclaration(GPBOneofOptions);
GPBObjCClassDeclaration(GPBTimestamp);
GPBObjCClassDeclaration(SENAnyRules);
GPBObjCClassDeclaration(SENBoolRules);
GPBObjCClassDeclaration(SENBytesRules);
GPBObjCClassDeclaration(SENDoubleRules);
GPBObjCClassDeclaration(SENDurationRules);
GPBObjCClassDeclaration(SENEnumRules);
GPBObjCClassDeclaration(SENFieldRules);
GPBObjCClassDeclaration(SENFixed32Rules);
GPBObjCClassDeclaration(SENFixed64Rules);
GPBObjCClassDeclaration(SENFloatRules);
GPBObjCClassDeclaration(SENInt32Rules);
GPBObjCClassDeclaration(SENInt64Rules);
GPBObjCClassDeclaration(SENMapRules);
GPBObjCClassDeclaration(SENMessageRules);
GPBObjCClassDeclaration(SENRepeatedRules);
GPBObjCClassDeclaration(SENSFixed32Rules);
GPBObjCClassDeclaration(SENSFixed64Rules);
GPBObjCClassDeclaration(SENSInt32Rules);
GPBObjCClassDeclaration(SENSInt64Rules);
GPBObjCClassDeclaration(SENStringRules);
GPBObjCClassDeclaration(SENTimestampRules);
GPBObjCClassDeclaration(SENUInt32Rules);
GPBObjCClassDeclaration(SENUInt64Rules);

#pragma mark - SENValidateRoot

@implementation SENValidateRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    static GPBExtensionDescription descriptions[] = {
      {
        .defaultValue.valueBool = NO,
        .singletonName = GPBStringifySymbol(SENValidateRoot_disabled),
        .extendedClass.clazz = GPBObjCClass(GPBMessageOptions),
        .messageOrGroupClass.clazz = Nil,
        .enumDescriptorFunc = NULL,
        .fieldNumber = 1071,
        .dataType = GPBDataTypeBool,
        .options = GPBExtensionNone,
      },
      {
        .defaultValue.valueBool = NO,
        .singletonName = GPBStringifySymbol(SENValidateRoot_required),
        .extendedClass.clazz = GPBObjCClass(GPBOneofOptions),
        .messageOrGroupClass.clazz = Nil,
        .enumDescriptorFunc = NULL,
        .fieldNumber = 1071,
        .dataType = GPBDataTypeBool,
        .options = GPBExtensionNone,
      },
      {
        .defaultValue.valueMessage = nil,
        .singletonName = GPBStringifySymbol(SENValidateRoot_rules),
        .extendedClass.clazz = GPBObjCClass(GPBFieldOptions),
        .messageOrGroupClass.clazz = GPBObjCClass(SENFieldRules),
        .enumDescriptorFunc = NULL,
        .fieldNumber = 1071,
        .dataType = GPBDataTypeMessage,
        .options = GPBExtensionNone,
      },
    };
    for (size_t i = 0; i < sizeof(descriptions) / sizeof(descriptions[0]); ++i) {
      GPBExtensionDescriptor *extension =
          [[GPBExtensionDescriptor alloc] initWithExtensionDescription:&descriptions[i]
                                                         usesClassRefs:YES];
      [registry addExtension:extension];
      [self globallyRegisterExtension:extension];
      [extension release];
    }
    // None of the imports (direct or indirect) defined extensions, so no need to add
    // them to this registry.
  }
  return registry;
}

@end

#pragma mark - SENValidateRoot_FileDescriptor

static GPBFileDescriptor *SENValidateRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"validate"
                                                 objcPrefix:@"SEN"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum SENKnownRegex

GPBEnumDescriptor *SENKnownRegex_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000HTTPHeaderName\000HTTPHeaderValue\000";
    static const int32_t values[] = {
        SENKnownRegex_Unknown,
        SENKnownRegex_HTTPHeaderName,
        SENKnownRegex_HTTPHeaderValue,
    };
    static const char *extraTextFormatInfo = "\002\001\004\346\344\000\002\004\346\345\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SENKnownRegex)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SENKnownRegex_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SENKnownRegex_IsValidValue(int32_t value__) {
  switch (value__) {
    case SENKnownRegex_Unknown:
    case SENKnownRegex_HTTPHeaderName:
    case SENKnownRegex_HTTPHeaderValue:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SENFieldRules

@implementation SENFieldRules

@dynamic typeOneOfCase;
@dynamic hasMessage, message;
@dynamic float_p;
@dynamic double_p;
@dynamic int32;
@dynamic int64;
@dynamic uint32;
@dynamic uint64;
@dynamic sint32;
@dynamic sint64;
@dynamic fixed32;
@dynamic fixed64;
@dynamic sfixed32;
@dynamic sfixed64;
@dynamic bool_p;
@dynamic string;
@dynamic bytes;
@dynamic enum_p;
@dynamic repeated;
@dynamic map;
@dynamic any;
@dynamic duration;
@dynamic timestamp;

typedef struct SENFieldRules__storage_ {
  uint32_t _has_storage_[2];
  SENFloatRules *float_p;
  SENDoubleRules *double_p;
  SENInt32Rules *int32;
  SENInt64Rules *int64;
  SENUInt32Rules *uint32;
  SENUInt64Rules *uint64;
  SENSInt32Rules *sint32;
  SENSInt64Rules *sint64;
  SENFixed32Rules *fixed32;
  SENFixed64Rules *fixed64;
  SENSFixed32Rules *sfixed32;
  SENSFixed64Rules *sfixed64;
  SENBoolRules *bool_p;
  SENStringRules *string;
  SENBytesRules *bytes;
  SENEnumRules *enum_p;
  SENMessageRules *message;
  SENRepeatedRules *repeated;
  SENMapRules *map;
  SENAnyRules *any;
  SENDurationRules *duration;
  SENTimestampRules *timestamp;
} SENFieldRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "float_p",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFloatRules),
        .number = SENFieldRules_FieldNumber_Float_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, float_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "double_p",
        .dataTypeSpecific.clazz = GPBObjCClass(SENDoubleRules),
        .number = SENFieldRules_FieldNumber_Double_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, double_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int32",
        .dataTypeSpecific.clazz = GPBObjCClass(SENInt32Rules),
        .number = SENFieldRules_FieldNumber_Int32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, int32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "int64",
        .dataTypeSpecific.clazz = GPBObjCClass(SENInt64Rules),
        .number = SENFieldRules_FieldNumber_Int64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, int64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uint32",
        .dataTypeSpecific.clazz = GPBObjCClass(SENUInt32Rules),
        .number = SENFieldRules_FieldNumber_Uint32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, uint32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uint64",
        .dataTypeSpecific.clazz = GPBObjCClass(SENUInt64Rules),
        .number = SENFieldRules_FieldNumber_Uint64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, uint64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sint32",
        .dataTypeSpecific.clazz = GPBObjCClass(SENSInt32Rules),
        .number = SENFieldRules_FieldNumber_Sint32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, sint32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sint64",
        .dataTypeSpecific.clazz = GPBObjCClass(SENSInt64Rules),
        .number = SENFieldRules_FieldNumber_Sint64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, sint64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fixed32",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFixed32Rules),
        .number = SENFieldRules_FieldNumber_Fixed32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, fixed32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fixed64",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFixed64Rules),
        .number = SENFieldRules_FieldNumber_Fixed64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, fixed64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sfixed32",
        .dataTypeSpecific.clazz = GPBObjCClass(SENSFixed32Rules),
        .number = SENFieldRules_FieldNumber_Sfixed32,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, sfixed32),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sfixed64",
        .dataTypeSpecific.clazz = GPBObjCClass(SENSFixed64Rules),
        .number = SENFieldRules_FieldNumber_Sfixed64,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, sfixed64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bool_p",
        .dataTypeSpecific.clazz = GPBObjCClass(SENBoolRules),
        .number = SENFieldRules_FieldNumber_Bool_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, bool_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "string",
        .dataTypeSpecific.clazz = GPBObjCClass(SENStringRules),
        .number = SENFieldRules_FieldNumber_String,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, string),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bytes",
        .dataTypeSpecific.clazz = GPBObjCClass(SENBytesRules),
        .number = SENFieldRules_FieldNumber_Bytes,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, bytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enum_p",
        .dataTypeSpecific.clazz = GPBObjCClass(SENEnumRules),
        .number = SENFieldRules_FieldNumber_Enum_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, enum_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "message",
        .dataTypeSpecific.clazz = GPBObjCClass(SENMessageRules),
        .number = SENFieldRules_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "repeated",
        .dataTypeSpecific.clazz = GPBObjCClass(SENRepeatedRules),
        .number = SENFieldRules_FieldNumber_Repeated,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, repeated),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "map",
        .dataTypeSpecific.clazz = GPBObjCClass(SENMapRules),
        .number = SENFieldRules_FieldNumber_Map,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, map),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "any",
        .dataTypeSpecific.clazz = GPBObjCClass(SENAnyRules),
        .number = SENFieldRules_FieldNumber_Any,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, any),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "duration",
        .dataTypeSpecific.clazz = GPBObjCClass(SENDurationRules),
        .number = SENFieldRules_FieldNumber_Duration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.clazz = GPBObjCClass(SENTimestampRules),
        .number = SENFieldRules_FieldNumber_Timestamp,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(SENFieldRules__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENFieldRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENFieldRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "type",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SENFieldRules_ClearTypeOneOfCase(SENFieldRules *message) {
  GPBDescriptor *descriptor = [SENFieldRules descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SENFloatRules

@implementation SENFloatRules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENFloatRules__storage_ {
  uint32_t _has_storage_[1];
  float const_p;
  float lt;
  float lte;
  float gt;
  float gte;
  GPBFloatArray *inArray;
  GPBFloatArray *notInArray;
} SENFloatRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFloatRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFloatRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENFloatRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENFloatRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENDoubleRules

@implementation SENDoubleRules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENDoubleRules__storage_ {
  uint32_t _has_storage_[1];
  GPBDoubleArray *inArray;
  GPBDoubleArray *notInArray;
  double const_p;
  double lt;
  double lte;
  double gt;
  double gte;
} SENDoubleRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDoubleRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENDoubleRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENDoubleRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENDoubleRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENInt32Rules

@implementation SENInt32Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENInt32Rules__storage_ {
  uint32_t _has_storage_[1];
  int32_t const_p;
  int32_t lt;
  int32_t lte;
  int32_t gt;
  int32_t gte;
  GPBInt32Array *inArray;
  GPBInt32Array *notInArray;
} SENInt32Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt32Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENInt32Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENInt32Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENInt32Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENInt64Rules

@implementation SENInt64Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENInt64Rules__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *inArray;
  GPBInt64Array *notInArray;
  int64_t const_p;
  int64_t lt;
  int64_t lte;
  int64_t gt;
  int64_t gte;
} SENInt64Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENInt64Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENInt64Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENInt64Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENInt64Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENUInt32Rules

@implementation SENUInt32Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENUInt32Rules__storage_ {
  uint32_t _has_storage_[1];
  uint32_t const_p;
  uint32_t lt;
  uint32_t lte;
  uint32_t gt;
  uint32_t gte;
  GPBUInt32Array *inArray;
  GPBUInt32Array *notInArray;
} SENUInt32Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt32Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENUInt32Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENUInt32Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENUInt32Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENUInt64Rules

@implementation SENUInt64Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENUInt64Rules__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *inArray;
  GPBUInt64Array *notInArray;
  uint64_t const_p;
  uint64_t lt;
  uint64_t lte;
  uint64_t gt;
  uint64_t gte;
} SENUInt64Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENUInt64Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENUInt64Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENUInt64Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENUInt64Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENSInt32Rules

@implementation SENSInt32Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENSInt32Rules__storage_ {
  uint32_t _has_storage_[1];
  int32_t const_p;
  int32_t lt;
  int32_t lte;
  int32_t gt;
  int32_t gte;
  GPBInt32Array *inArray;
  GPBInt32Array *notInArray;
} SENSInt32Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSInt32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt32Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSInt32Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENSInt32Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENSInt32Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENSInt64Rules

@implementation SENSInt64Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENSInt64Rules__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *inArray;
  GPBInt64Array *notInArray;
  int64_t const_p;
  int64_t lt;
  int64_t lte;
  int64_t gt;
  int64_t gte;
} SENSInt64Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSInt64Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSInt64Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENSInt64Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENSInt64Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENFixed32Rules

@implementation SENFixed32Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENFixed32Rules__storage_ {
  uint32_t _has_storage_[1];
  uint32_t const_p;
  uint32_t lt;
  uint32_t lte;
  uint32_t gt;
  uint32_t gte;
  GPBUInt32Array *inArray;
  GPBUInt32Array *notInArray;
} SENFixed32Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFixed32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed32Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFixed32Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENFixed32Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENFixed32Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENFixed64Rules

@implementation SENFixed64Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENFixed64Rules__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *inArray;
  GPBUInt64Array *notInArray;
  uint64_t const_p;
  uint64_t lt;
  uint64_t lte;
  uint64_t gt;
  uint64_t gte;
} SENFixed64Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFixed64,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENFixed64Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENFixed64Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENFixed64Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENFixed64Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENSFixed32Rules

@implementation SENSFixed32Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENSFixed32Rules__storage_ {
  uint32_t _has_storage_[1];
  int32_t const_p;
  int32_t lt;
  int32_t lte;
  int32_t gt;
  int32_t gte;
  GPBInt32Array *inArray;
  GPBInt32Array *notInArray;
} SENSFixed32Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSFixed32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed32Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSFixed32Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSFixed32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENSFixed32Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENSFixed32Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENSFixed64Rules

@implementation SENSFixed64Rules

@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENSFixed64Rules__storage_ {
  uint32_t _has_storage_[1];
  GPBInt64Array *inArray;
  GPBInt64Array *notInArray;
  int64_t const_p;
  int64_t lt;
  int64_t lte;
  int64_t gt;
  int64_t gte;
} SENSFixed64Rules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_Lt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_Lte,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_Gt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_Gte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSFixed64,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENSFixed64Rules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENSFixed64Rules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeSFixed64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENSFixed64Rules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENSFixed64Rules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENBoolRules

@implementation SENBoolRules

@dynamic hasConst_p, const_p;

typedef struct SENBoolRules__storage_ {
  uint32_t _has_storage_[1];
} SENBoolRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBoolRules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENBoolRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENBoolRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENStringRules

@implementation SENStringRules

@dynamic wellKnownOneOfCase;
@dynamic hasConst_p, const_p;
@dynamic hasLen, len;
@dynamic hasMinLen, minLen;
@dynamic hasMaxLen, maxLen;
@dynamic hasLenBytes, lenBytes;
@dynamic hasMinBytes, minBytes;
@dynamic hasMaxBytes, maxBytes;
@dynamic hasPattern, pattern;
@dynamic hasPrefix, prefix;
@dynamic hasSuffix, suffix;
@dynamic hasContains, contains;
@dynamic hasNotContains, notContains;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;
@dynamic email;
@dynamic hostname;
@dynamic ip;
@dynamic ipv4;
@dynamic ipv6;
@dynamic uri;
@dynamic uriRef;
@dynamic address;
@dynamic uuid;
@dynamic wellKnownRegex;
@dynamic hasStrict, strict;

typedef struct SENStringRules__storage_ {
  uint32_t _has_storage_[2];
  SENKnownRegex wellKnownRegex;
  NSString *const_p;
  NSString *pattern;
  NSString *prefix;
  NSString *suffix;
  NSString *contains;
  NSMutableArray *inArray;
  NSMutableArray *notInArray;
  NSString *notContains;
  uint64_t minLen;
  uint64_t maxLen;
  uint64_t minBytes;
  uint64_t maxBytes;
  uint64_t len;
  uint64_t lenBytes;
} SENStringRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "const_p",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Const_p,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, const_p),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "minLen",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_MinLen,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, minLen),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "maxLen",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_MaxLen,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, maxLen),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "minBytes",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_MinBytes,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, minBytes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "maxBytes",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_MaxBytes,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, maxBytes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "pattern",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Pattern,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, pattern),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "prefix",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Prefix,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, prefix),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "suffix",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Suffix,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, suffix),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "contains",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Contains,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, contains),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "inArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_InArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, inArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "notInArray",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_NotInArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, notInArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "email",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Email,
        .core.hasIndex = -1,
        .core.offset = 12,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "hostname",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Hostname,
        .core.hasIndex = -1,
        .core.offset = 13,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ip",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Ip,
        .core.hasIndex = -1,
        .core.offset = 14,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ipv4",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Ipv4,
        .core.hasIndex = -1,
        .core.offset = 15,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ipv6",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Ipv6,
        .core.hasIndex = -1,
        .core.offset = 16,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "uri",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Uri,
        .core.hasIndex = -1,
        .core.offset = 17,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "uriRef",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_UriRef,
        .core.hasIndex = -1,
        .core.offset = 18,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "len",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Len,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, len),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueUInt64 = 0ULL,
        .core.name = "lenBytes",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_LenBytes,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, lenBytes),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeUInt64,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "address",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Address,
        .core.hasIndex = -1,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "uuid",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Uuid,
        .core.hasIndex = -1,
        .core.offset = 20,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "notContains",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_NotContains,
        .core.hasIndex = 11,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, notContains),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = SENKnownRegex_Unknown,
        .core.name = "wellKnownRegex",
        .core.dataTypeSpecific.enumDescFunc = SENKnownRegex_EnumDescriptor,
        .core.number = SENStringRules_FieldNumber_WellKnownRegex,
        .core.hasIndex = -1,
        .core.offset = (uint32_t)offsetof(SENStringRules__storage_, wellKnownRegex),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = YES,
        .core.name = "strict",
        .core.dataTypeSpecific.clazz = Nil,
        .core.number = SENStringRules_FieldNumber_Strict,
        .core.hasIndex = 21,
        .core.offset = 22,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENStringRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(SENStringRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown | GPBDescriptorInitializationFlag_FieldsWithDefault)];
    static const char *oneofs[] = {
      "wellKnown",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SENStringRules_ClearWellKnownOneOfCase(SENStringRules *message) {
  GPBDescriptor *descriptor = [SENStringRules descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SENBytesRules

@implementation SENBytesRules

@dynamic wellKnownOneOfCase;
@dynamic hasConst_p, const_p;
@dynamic hasLen, len;
@dynamic hasMinLen, minLen;
@dynamic hasMaxLen, maxLen;
@dynamic hasPattern, pattern;
@dynamic hasPrefix, prefix;
@dynamic hasSuffix, suffix;
@dynamic hasContains, contains;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;
@dynamic ip;
@dynamic ipv4;
@dynamic ipv6;

typedef struct SENBytesRules__storage_ {
  uint32_t _has_storage_[2];
  NSData *const_p;
  NSString *pattern;
  NSData *prefix;
  NSData *suffix;
  NSData *contains;
  NSMutableArray *inArray;
  NSMutableArray *notInArray;
  uint64_t minLen;
  uint64_t maxLen;
  uint64_t len;
} SENBytesRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "minLen",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_MinLen,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, minLen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "maxLen",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_MaxLen,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, maxLen),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "pattern",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Pattern,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, pattern),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "prefix",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Prefix,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, prefix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "suffix",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Suffix,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, suffix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contains",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Contains,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, contains),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ip",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Ip,
        .hasIndex = -1,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ipv4",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Ipv4,
        .hasIndex = -1,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "ipv6",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Ipv6,
        .hasIndex = -1,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "len",
        .dataTypeSpecific.clazz = Nil,
        .number = SENBytesRules_FieldNumber_Len,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENBytesRules__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENBytesRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENBytesRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "wellKnown",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void SENBytesRules_ClearWellKnownOneOfCase(SENBytesRules *message) {
  GPBDescriptor *descriptor = [SENBytesRules descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SENEnumRules

@implementation SENEnumRules

@dynamic hasConst_p, const_p;
@dynamic hasDefinedOnly, definedOnly;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENEnumRules__storage_ {
  uint32_t _has_storage_[1];
  int32_t const_p;
  GPBInt32Array *inArray;
  GPBInt32Array *notInArray;
} SENEnumRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnumRules_FieldNumber_Const_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENEnumRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "definedOnly",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnumRules_FieldNumber_DefinedOnly,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnumRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENEnumRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENEnumRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENEnumRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENEnumRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENEnumRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENMessageRules

@implementation SENMessageRules

@dynamic hasSkip, skip;
@dynamic hasRequired, required;

typedef struct SENMessageRules__storage_ {
  uint32_t _has_storage_[1];
} SENMessageRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "skip",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMessageRules_FieldNumber_Skip,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "required",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMessageRules_FieldNumber_Required,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENMessageRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENMessageRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENRepeatedRules

@implementation SENRepeatedRules

@dynamic hasMinItems, minItems;
@dynamic hasMaxItems, maxItems;
@dynamic hasUnique, unique;
@dynamic hasItems, items;

typedef struct SENRepeatedRules__storage_ {
  uint32_t _has_storage_[1];
  SENFieldRules *items;
  uint64_t minItems;
  uint64_t maxItems;
} SENRepeatedRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minItems",
        .dataTypeSpecific.clazz = Nil,
        .number = SENRepeatedRules_FieldNumber_MinItems,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENRepeatedRules__storage_, minItems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "maxItems",
        .dataTypeSpecific.clazz = Nil,
        .number = SENRepeatedRules_FieldNumber_MaxItems,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENRepeatedRules__storage_, maxItems),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unique",
        .dataTypeSpecific.clazz = Nil,
        .number = SENRepeatedRules_FieldNumber_Unique,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "items",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFieldRules),
        .number = SENRepeatedRules_FieldNumber_Items,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENRepeatedRules__storage_, items),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENRepeatedRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENRepeatedRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENMapRules

@implementation SENMapRules

@dynamic hasMinPairs, minPairs;
@dynamic hasMaxPairs, maxPairs;
@dynamic hasNoSparse, noSparse;
@dynamic hasKeys, keys;
@dynamic hasValues, values;

typedef struct SENMapRules__storage_ {
  uint32_t _has_storage_[1];
  SENFieldRules *keys;
  SENFieldRules *values;
  uint64_t minPairs;
  uint64_t maxPairs;
} SENMapRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minPairs",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMapRules_FieldNumber_MinPairs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SENMapRules__storage_, minPairs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "maxPairs",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMapRules_FieldNumber_MaxPairs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SENMapRules__storage_, maxPairs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "noSparse",
        .dataTypeSpecific.clazz = Nil,
        .number = SENMapRules_FieldNumber_NoSparse,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "keys",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFieldRules),
        .number = SENMapRules_FieldNumber_Keys,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENMapRules__storage_, keys),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "values",
        .dataTypeSpecific.clazz = GPBObjCClass(SENFieldRules),
        .number = SENMapRules_FieldNumber_Values,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENMapRules__storage_, values),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENMapRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENMapRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENAnyRules

@implementation SENAnyRules

@dynamic hasRequired, required;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENAnyRules__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *inArray;
  NSMutableArray *notInArray;
} SENAnyRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "required",
        .dataTypeSpecific.clazz = Nil,
        .number = SENAnyRules_FieldNumber_Required,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENAnyRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENAnyRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = Nil,
        .number = SENAnyRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENAnyRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENAnyRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENAnyRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENDurationRules

@implementation SENDurationRules

@dynamic hasRequired, required;
@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic inArray, inArray_Count;
@dynamic notInArray, notInArray_Count;

typedef struct SENDurationRules__storage_ {
  uint32_t _has_storage_[1];
  GPBDuration *const_p;
  GPBDuration *lt;
  GPBDuration *lte;
  GPBDuration *gt;
  GPBDuration *gte;
  NSMutableArray *inArray;
  NSMutableArray *notInArray;
} SENDurationRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "required",
        .dataTypeSpecific.clazz = Nil,
        .number = SENDurationRules_FieldNumber_Required,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_Const_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_Lt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_Lte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_Gt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_Gte,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_InArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, inArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notInArray",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENDurationRules_FieldNumber_NotInArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SENDurationRules__storage_, notInArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENDurationRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENDurationRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SENTimestampRules

@implementation SENTimestampRules

@dynamic hasRequired, required;
@dynamic hasConst_p, const_p;
@dynamic hasLt, lt;
@dynamic hasLte, lte;
@dynamic hasGt, gt;
@dynamic hasGte, gte;
@dynamic hasLtNow, ltNow;
@dynamic hasGtNow, gtNow;
@dynamic hasWithin, within;

typedef struct SENTimestampRules__storage_ {
  uint32_t _has_storage_[1];
  GPBTimestamp *const_p;
  GPBTimestamp *lt;
  GPBTimestamp *lte;
  GPBTimestamp *gt;
  GPBTimestamp *gte;
  GPBDuration *within;
} SENTimestampRules__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "required",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTimestampRules_FieldNumber_Required,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "const_p",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTimestampRules_FieldNumber_Const_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, const_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTimestampRules_FieldNumber_Lt,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, lt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lte",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTimestampRules_FieldNumber_Lte,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, lte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gt",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTimestampRules_FieldNumber_Gt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, gt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gte",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBTimestamp),
        .number = SENTimestampRules_FieldNumber_Gte,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, gte),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ltNow",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTimestampRules_FieldNumber_LtNow,
        .hasIndex = 7,
        .offset = 8,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "gtNow",
        .dataTypeSpecific.clazz = Nil,
        .number = SENTimestampRules_FieldNumber_GtNow,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "within",
        .dataTypeSpecific.clazz = GPBObjCClass(GPBDuration),
        .number = SENTimestampRules_FieldNumber_Within,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(SENTimestampRules__storage_, within),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SENTimestampRules class]
                                     rootClass:[SENValidateRoot class]
                                          file:SENValidateRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SENTimestampRules__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
